# 4. 분산 큐
- 잘 정의된 인터페이스를 경계로 나뉜 작고 독립적인 블록들 사이의 통신과 조율 담당
  - 결합도 완화: 컴포넌트 사이의 강한 결합이 사라짐
  - 규모 확장성: Pub/Sub 시스템을 통해 트래픽 부하에 맞게 독립적으로 늘릴수 있음
  - 가용성 개선: 특정 컴포넌트에 장애가 발생해도 다른 컴포는트는 큐와 계속 상호 작용
  - 성능 개선: 메시지 큐를 이용하면 비동기 통신이 쉽게 가능
- 메시지 큐 대 이벤트 스트리밍 플랫폼
  - 최근 들어 메시지 큐와 이벤트 스트리밍 플랫폼간 차이가 없어짐

## 4.1 문제 이해 및 설계 범위 확정
##### 기능 요구사항
- 생산자는 메시지 큐에 메시지를 송신
- 소비자는 메시지 큐를 통해 메시지를 수신
- 메시지는 반복적 수신 또는 한번만 수신 가능하게 할 수 있어야함
- 오래된 이력 데이터는 삭제
- 메시지 크기는 KB 수준
- 메시지가 생성된 순서대로 소비자에게 전달할 수 있어야 함
- 메시지 전달 방식은 최소 한 번, 최대 한 번, 정확히 한 번 가운데 설정할 수 있어야 함

##### 기능 요구사항
- 높은 대역폭과 낮은 전송 지연 가운데 하나를 설정 선택 가능
- 규모 확장성: 분산 시스템이며, 메시지량이 급증해도 처리 가능
- 지속성 및 내구성: 데이터는 디스크에 지속적으로 보관 및 여러 노드에 복제

##### 전통적 메시지 큐와 다른점
- 전통적인 메시지 큐는 이벤트 스트리밍 플랫폼과 아래와 다름
  - 메시지 보관 문제를 중요하게 다루지 않음
    - 메시지가 소비자에 전달되는 충분한 기간 동안만 메모리에 보관
    - 처리 용량을 넘어서면 디스크에 보관히지만, 이벤트 스트리밍 플랫폼 보단 용량이 매우 낮음
  - 전달 순서를 보장하지 않음

## 4.2 개략적 설계안 제시 및 동의 구하기
- 메시지 큐의 기본 기능<br>
<img src="img.png" alt="drawing" width="500px"/><br>
  - 생산자는 메시지를 메시지 큐에 발행
  - 소비자는 큐를 구독 및 구독한 메시지 소비
  - 생산자와 소비자 사이의 결합을 느슨, 생산자와 소비자의 독립적인 운영 및 규모 확장을 가능하게 하는 역할
  - 클라이언트 입장에서 서버 역할을 하는건 메시지 큐이며, 이 클라리언트와 서버는 네트워크 통신
- 메시지 모델
  - 가장 널리 쓰이는 메시지 모델은 일대일과 발행 구독(Pub/Sub) 모델

##### 일대일 모델
<img src="img_1.png" alt="drawing" width="500px"/><br>
- 큐에 전송된 메시지는 오직 한 소비자만 가져갈 수 있음
- 어떤 소비자가 메시지를 가져갔다는 사실을 큐에 알리면(ack) 해당 메시지는 \
- 큐에서 삭제
  - 해당 모델은 데이터 보관을 지원하지 않음
  - 본 설계안은 메시지를 2 주 동안은 보관할 수 있도록 하는 지속적 계층을 포함, 해당 계층을 통해 메시지가 반복적으로 소비

##### 발행-구독 모델
<img src="img_2.png" alt="drawing" width="500px"/><br>
- 발행-구독 모델을 설명하려면 토픽(topic)이라는 새로운 개념을 도입
  - 메시지를 주제별로 정리하는데 사용
  - 메시지 큐 서비스 전반에 고유한 이름을 가짐
- 토픽에 전달된 메시지는 해당 토픽을 구독하는 모든 소비자에 전달
- 발행-구독 모델은 토픽을 통해 구현할 수 있으며, 일대일 모델은 소비자 그룹을 통해 지원

##### 토픽,파티션,브로커
- 토픽은 보관되는데, 서버 하나가 감당하기 힘든 상황이 벌어지면? 파티션, 즉 샤당 기법 활용<br>
  <img src="img_3.png" alt="drawing" width="350px"/><br>
  - 토픽을 여러 파티션으로 분할한 다음에 메시지를 모든 파티션에 균등하게 나눠 보냄
  - 파티션은 메시지 큐 클러스트 내의 서버에 고르게 분산 배치
  - 파티션을 유지하는 서버는 보통 브로커라고 부름 
    - 브로커에 분산하는 것이 높은 규모 확장성을 달성하는 비결
  - 토픽의 용량을 확장하고 싶으면 파티션 개수를 늘리면 됨
  - 토픽 파티션은 FIFO 처럼 동작 -> 같은 파티션 안에서는 메시지 순서가 유지

<img src="img_4.png" alt="drawing" width="500px"/><br>

##### 소비자 그룹
- 소비자 그룹 내 소비자는 토픽에서 메시지를 소비하기 위해 노력
  - 하나의 소비자 그룹은 여러 토픽을 구독할 수 있고 오프셋을 별도로 관리<br>
    <img src="img_5.png" alt="drawing" width="300px"/><br>
- 데이터를 병렬로 읽으면 대역폭 측면에서 좋지만 같은 파티션 안에 있는 메시지를 순서대로 소비할 수는 없음
  - 소비자-1과 소비자-2가 같은 파티션-1의 메시지를 읽어야 하면 순서 보장이 안됨 
- 해결 방안으로 하나의 소비자 그룹의 하나의 소비자만 특정 파티션의 메시지 소비
  - 다만, 그룹 내 소비자의 수가 구독하는 토픽의 파티션 수보다 크면 어떤 소비자는 해당 토픽에서 데이터를 일지 못하게 됨
  - 파티션의 메시지는 오직 한 소비자만 가져가는 방법은 일대일 모델에 수렴
    - 처리 용량을 늘리려면 소비자를 늘리면 됨

##### 개략적 설계안
<img src="img_6.png" alt="drawing" width="500px"/><br>
- 클라이언트
  - 생산자: 메시지를 특정 토픽 송신
  - 소비자 그룹: 토픽을 구독하고 메시지를 소비
- 핵심 서비스 및 저장소
  - 브로커: 파티션들을 유지, 하나의 파티션은 특정 토픽에 대한 메시지의 부분 집합을 유지
  - 저장소
    - 데이터 저장소: 메시지는 파티션 내 데이터 저장소에 보관
    - 상태 저장소: 소비자 상태는 이 저장소에 유지
    - 메타데이터 저장소: 토픽 설정, 토픽 속성 등은 이 저장소에 유지
  - 조정 서비스
    - 서비스 탐색: 어떤 브로커가 살아 있는지 알려줌
    - 리더 산출: 브로커 가운데 하나는 컨트롤러 역할을 담당, 파티션 배치를 책임
    - 아파치 주키퍼나 etcd가 보통 컨트롤러 선출을 담당하는 역할 

## 4.3 상세 설계
- 데이터 장기 보관 요구사항 만족과 함께 높은 대역폭 제공을 위해 세가지 중요한 결정
  - 회전 디스크의 높은 순차 탐색 성능과 현대적 운영체제 지원의 디스크 캐시 적략
  - 메시지가 아무 수정 없이도 전송이 가능하도록 메시지 자료 구조 설계 및 활용
  - 일괄 처리를 우선하는 시스템 설계 -> 소규모 I/O 많으면 높은 대역폭 지원이 어려움

##### 데이터 저장소
- 메시지 큐의 트래픽 패턴
  - 읽기와 쓰기가 빈번하게 잃어남
  - 갱신/삭제 연산이 발생하지 않음
    - 위에 내용은 데이터 스트리밍 관련 데이터 지속성 부분
    - 전통적인 메시지 큐는 메시지가 신속하게 전달되지 못하는 것 외에는 메시지를 지속적으로 보관히자 않음
  - 순차적인 읽기/쓰기가 대부분
- 선택지 1: 데이터 베이스
  - 데이터 베이스 종류
    - 관계형 데이터배이스: 토픽별 테이블 생성 및 토픽 당 메시지는 테이블 내 레코드
    - NoSQL 데이터베이스: 토픽별로 컬렉션을 생성 및 토픽 당 메시지는 하나의 문서
  - 읽기 연산과 쓰기 연산이 동시에 대규모로 빈번하게 발생 상황을 잘 처리하는 데이터베이스는 설계하기 어려움 -> 오히려 병목현상으로 될 가능성이 존재
- 선택지 2: 쓰기 우선 로그(Write-Ahead Log,WAL)
  - 새로운 항목이 추가되기만 하는(append-only) 일반 파일
  - 
## 4.4 마무리
- 시간이 조금 남으면 면접관과 논의할 부분
  - 프로토콜: 노드 사이에 오고 가는 데이터에 관한 규칙, 문법 및 API 규정
    - 메시지 생산과 소비 및 박동 메시지 교환 등의 모든 활동을 설명
    - 대용량 데이터를 효과적으로 전송할 방법을 설명
    - 데이터의 무결성을 검증할 방법을 기술
- 유명한 프로토콜로 AMOP, 카프카 프로토콜 등 존재
  - 메시지 소비 재시도
    - 실패한 메시지를 재처리하려면, 재시도 전용 토픽에 보낸다음 나중에 다시 소비
  - 이력 데이터 아카이브
    - 시간 기반 혹은 용량 기반 로그 보관 메커니즘이 있을시, 이미 삭제된 메시지 처리를 원할때는 HDFS같은 대용량 저장소 시스템이나 객체 저장소에서 보관된 메시지 활용
