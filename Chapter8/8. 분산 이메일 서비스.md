# 8. 분산 이메일 서비스
- 지메일, 아웃룩과 같은 대규모 이메일 서비스 설계

## 8.1 문제 이해 및 설계 범위 확정
- 오랜 세월 이메일 서비스는 복잡성과 규모 면에서 크게 달라짐 -> 45분동안 설계하기 힘듬
##### 비기능 요구사항
- 안전성: 이메일 데이터는 소실되어서는 안됨
- 가용성: 이메일과 사용자 데이터를 여러 노드에 복제하여 가용성 확보
- 확장성: 사용자 수가 늘어나도 감당 가능 및 시스템 저하 방지
- 유연성과 확장성: 새 컴포넌트를 쉽게 기능 추가 및 성능 개선할 수 있는 유연한 확장 가능 -> POP나 IMAP 같은 기존 이메일 프로토콜은 기능이 매우 제한적임

##### 개략적 규모 추정
- 10억 명의 사용자
- 한 사람이 하루에 보내는 평균 이메일 수 10건 가정 -> QPS = 10<sup>9</sup> x 10 / 10<sup>5</sup> = 100,000
- 한 사람이 하루에 수신하는 이메일 수는 평균 40건 가정, 이메일 하나의 메타데이터는 평균 50KB(첨부파일 포함x)
- 1년간 메타데이터를 유지하기 위한 스토리지 요구사항은 730pb
  - 메타데이터를 데이터베이스에 저장한다고 가정 
  - 10억명 사용자 x 하루 40건 이메일 x 365일 x 50kb = 730pb
- 첨부 파일을 포함하는 이메일의 비율은 20%이며, 첨부 파일의 평균 크기는 500kb라고 가정
- 1년간 첨부 파일을 보관하는 데 필요한 저장 용량은 1,460PB
  - 10억 명 사용자 x 하루 40개 이메일 x 365일 x 20% x 500kb

## 8.2 개략적 설계안 제시 및 동의 구하기
- 이메일 서버에 대해 알아야 할 몇가지 기본적인 사항과 더불어 이메일 서버 흐름 논의
##### 이메일 101
- 이메일을 주고 받는 프로토콜 존재
  - SMTP(Simple Mail Transfer Protocol)
    - 이메일을 한 서버에서 다른 서버로 보내는 표준 프로토콜
  - POP(Post Office Protocol)
    - 이메일 클라이언트가 원격 메일 서버에서 이메일을 수신하고 다운로드하기 위해 사용하는 표준 프로토콜
    - 일단 단말로 다운로드 된 이메일은 서버에서 삭제됨 -> 한대의 단말에서만 이메일을 읽을 수 있음
    - 클라이언트는 일부 이메일만 읽을 수 없음 -> 용량이 큰 첨부 파일이 붙은 이메일은 읽으려면 오래 걸림
  - IMAP(Internet Mail Access Protocol)
    - 이메일을 수신하는 또 다른 표준의 프로토콜
    - 클릭하지 않으면 메시지는 다운로드 되지 않으며, 메일서버에서도 지워지지도 않음 -> 여러 단말에서 이메일을 읽을 수 있음
    - 인터넷 속도가 느려도 잘 동작하며, 실제로 열기 전에는 헤더만 다운로드함
  - HTTPS
    - 메일 전송 프로토콜은 아니지만 웹 기반 이메일 시스템의 메일함 접속에 이용 가능
    - 아웃룩은 액티브싱크라는 HTTPS 기반 자체 프로톸콜을 통해 모바일 단말과의 통신을 처리
- 도메인 이름 서비스(DNS)<br>
  <img src="269 8.2.png" alt="drawing" width="300px"/><br>
  - DNS 서버는 수신자 도메인의 메일 교환기 레코드(Mail Exchange,MX) 검색에 이용
  - 우선 순위 값은 선호도를 나타내며, 그 값이 낮으면 우선순위가 높아서 선호
    - 위에 그림에서 gmail-smtp-in.l.google.com. 이 우선순위가 가장 높으므로(5) 최우선
  - 우선 순위 높은 서버에 접속하여 메시지를 전송 시도 -> 실패 시, 다음 순위 서버 접속
- 첨부파일
  - 이메일 메시지와 같이 전송되며, base64로 인코딩되어 전송
  - 일반적으로 크기 제한 존재
##### 전통적 메일 서버
- 보통 서버 한대로 운용, 사용자가 많지 않을때는 잘 동작하는 시스템
- 전통적 메일 서버 아키텍처<br>
<img src="270 8.3.png" alt="drawing" width="500px"/><br>
  - ① 앨리스가 아웃룩 메일서버로 SMTP 프로토콜을 통해 메일 발송
  - ② 아웃룻 메일서버는 DNS 질의를 통해 수신사 SMTP 서버 주소를 찾고, 수신사 지메일 SMTP 서버로 메일 발송(프로토콜 SMTP)
  - ③ 지메일 서버는 이메일을 저장하고 수신자인 밥이 읽어 갈 수 있도록 처리
  - ④ 밥이 지메일에 로그인하면 지메일 클라이언트는 IMAP/POP 서버를 통해 새 메일을 수신
- 저장소<br>
<img src="271 8.4.png" alt="drawing" width="500px"/><br>
  - 이메일을 파일 시스템의 디렉터리에 저장 -> 각각의 이메일은 고유한 이름을 가진 별도 파일로 보관, 각 사용자의 설정 데이터와 메일함은 사용자 디렉터리에 보관
  - 사용자가 많지 않을때는 잘 동작하지만, 수십억 개의 이메일을 검색하고 백업하는 목적으로 활용 곤란
    - 파일 구조가 복잡해지고 디스크 I/O 병목 발생
    - 이메일을 서버의 파일 시스템에 보관하므로 가용성과 안전성 요구사항 미충족
- POP, IMAP, SMTP 같은 이메일 프로토콜은 멀티미디어, 메일 타래, 검색 등 미지원 
##### 분산 메일 서버
- 현대적 사용 패턴을 지원하고 확장성과 안전성 문제 해결
  - 이메일 API
    - 메일 클라이언트마다, 이메일 생명주기 단계마다 달라질 수 있음
      - 모바일 단말 클라이언트를 위한 SMTP/POP/IMAP API
      - 송신 측 메일 서버와 수신 측 메일 서버 간의 SMTP 통신
      - 대화형 웹 기반 이메일 애플리케이션을 위한 HTTP 기반 RESTful API
    - 웹메일 통신에는 일반적으로 HTTP 프로토콜이 쓰임
    - ① POST /v1/messages 엔드포인트
      - To,Tc,Bcc 헤더에 명시된 수신자에게 메시지를 전송
    - ② GET /v1/folders 엔드포인트
      - 주어진 이메일 계정에 존재하는 모든 폴더를 반환

    ```
    응답 형식
     [{
        id: string      고유한 폴더 식별자
        name: string    폴더 이름(다음 폴더 가운데 하나 [All, Archive, Drafts, Flagged, Junk, Sent, Trash])
        user_id: string 계정 소유자 ID
     }]
    ```

    - ③ GET /v1/folders/{:folder_id}/messages 엔드포인트
      - 주어진 폴더 아래의 모든 메시지를 반환
      - 실제로는 페이지 분할을 지원하는 등 훨씬 복잡할 수 있음

    ```
    응답 형식
    페이지 객체 목록
    ```

    - ④ GET /v1/messages/{:message_id} 엔드포인트
      - 주어진 특정 메시지에 대한 모든 정보를 반환
      - 핵심 구성 요소로, 발신자, 수신자, 메시지 제목 등의 정보로 구성

    ```
    응답 형식
     [{
        user_id: string                       계정 주의 ID
        from: name: string, email:string      발신자의 <이름, 이메일> 쌍
        to: [name: string, email:string]      수신자 <이름, 이메일> 쌍의 목록
        subject: string                       이메일 제목
        body: string                          이메일 본문
        is_read: Boolean                      수신자가 메시지를 읽었는지 여부
    }]
    ```
- 분산 이메일 서버 아키텍처<br>
  - 소수 사용자를 처리하는 이메일 서버 구성은 어렵지 않지만, 한대 이상의 서버 규모를 늘리는 것은 어려움
  - 여러 서버간의 데이터 동기화 부분도 어려우며, 수신자 메일 서버에서 이메일이 스팸 처리되지 않도록 하는 문제도 까다로움
  - 클라우드 기술을 활용한 개력적인 설계안은 다음과 같음<br>
    <img src="274 8.5.png" alt="drawing" width="500px"/><br>
    - 웹메일: 웹브라우저를 사용해 메일을 받고 보냄
    - 웹서버: 로그인, 가입, 사용자 프로파일등에 관리 기능 담당, 이메일 발송 및 폴더 목록 확인도 웹서버를 통함
    - 실시간 서버: 새로운 이메일 내역을 클라이언트에 실시간으로 전달
      - 실시간 통신 지원 방안으로 롱 폴링이나 웹 소켓 존재
      - 웹 소켓이 좀더 우아하지만 여의치 않으면 롱폴링 사용
    - 메타데이터 데이터베이스: 이메일 제목, 본문, 발신인, 수신인 등 메타데이터를 저장하는 데이터베이스
    - 첨부 파일 저장소: 아마존 S3 같은 객체 저장소를 활용, 대용량 파일 저장에 적합
      - 카산드라 같은 컬럼 기반 NoSQL 데이터베이스는 용도로 적합하지 않음
        - 카산드라가 BLOB 자료형을 지원하고 최대 크기가 2GB지만 실질적으로 1MB 이상 파일 지원 못함
        - 카산드라에 첨부 파일을 저장하면 레코드 캐시를 사용하기 어려움 -> 첨부 파일이 너무 많은 메모리를 잡아 먹음
    - 분산 캐시: 수신된 이메일은 자주 읽을 가능성이 높으므로 메모리에 캐시를 두어 메일 표시 시간 단축
    - 검색 저장소: 검색 저장소는 분산 문서 저장소, 고속 텍스트 검색을 지원하는 역 인덱스를 자료 구조로 사용

- 이메일 전송 절차<br>
  <img src="276 8.6.png" alt="drawing" width="500px"/><br>
  - ① 메일 작성 후 전송 요청, 요청은 로드밸런스로 전송
  - ② 처리율 제한 한도를 넘지 않은 선에서 요청을 웹서버로 전달
  - ③ 웹서버 역할
    - 기본적인 이메일 검증: 이메일 크기 한도와 같은 사전 정의된 규칙으로 검사
    - 수신자 이메일 주소 도메인이 송신자 이메일 주소 도메인과 같은지 검사
      - 같다면? 스팸여부와 바이러스 감염 여부 검사
      - 검사 이상 없다면? 송신인의 '보낸 편지함'과 수신인의 '받은 편지함'에 저장
  - ④ 메시지 큐
    - 4.a 기본적인 검증을 통과한 이메일은 외부 전송 큐로 전달, 크기가 너무 크면 첨부 파일은 객체 저장소에 따로 저장하고 이메일 안에 저장 위치에 대한 참조 정보만 보관
    - 4.b 기본적인 검증에 실패한 이메일은 에러 큐에 보관
  - ⑤ 외부 전송 담당 SMTP 작업 프로세스는 외부 전송 큐에서 메시지에 대해 스팸 및 바이러스 감염 여부 확인
  - ⑥ 검증 절차를 통과한 이메일은 '보낸 편지함'에 저장
  - ⑦ 외부 전송 담당 SMTP 작업 프로세스가 수신자의 메일 서버로 메일 전송
  - 분산 메시지 큐는 비동기적 메일 처리를 가능케 하는 핵심적 컴포넌트
  - 웹서버와 외부 전송 담당 SMTP 분리로 독립적으로 조정 가능
  - 외부 전송 큐의 크기를 모니터링할 때 각별 주의 -> 메일 처리 되지 않고 큐에 오랫동안 남아있으면 이유 분석 필요
    - 수신자 측 메일 서버에 장애 발생: 나중에 메일 다시 전송해야 함, 지수적 백오프가 좋은 전략
    - 이메일을 보낼 큐의 소비자 수가 불충분: 더 많은 소비자를 추가하여 처리 시간을 단축
- 이메일 수신 절차<br>
  <img src="278 8.7.png" alt="drawing" width="500px"/><br>
  - ① 이메일이 SMTP 로드밸런서에 도착
  - ② 로드밸런서는 트래픽을 여러 SMTP 서버로 분산, SMTP 연결에는 이메일 수락 정책 구성 적용 가능(유효하지 않은 이메일 반송)
  - ③ 첨부 파일이 큐에 들어가기 너무 큰 경우에는 첨부 파일 저장소에 보관
  - ④ 이메일을 수신 이메일 큐에 넣음, 큐는 메일 처리 작업 프로세스와 SMTP 서버 간의 결합도를 낮추어 독립적 규모 확장 가능
  - ⑤ 메일 처리 작업 프로세스는 스팸 메일을 걸러내고 바이러스 차단 역할, 아래 절차는 검증이 끝난 이메일 대상
  - ⑥ 이메일을 메일 저장소, 캐시, 객체 저장소 등에 보관
  - ⑦ 수신자가 온라인 상태인 경우 이메일을 실시간 서버로 전달
  - ⑧ 실시간 서버는 클라이언트에게 새 메일에 대해 실시간 전달(웹 소켓)
  - ⑨ 오프라인 상태 사용자의 이메일은 저장소 계층에 보관, 추후 RESTful API를 통해 확인 가능
  - ⑩ 웹 서버는 새로운 이메일을 저장소 계층에서 가져와 클라이언트에게 반환

## 8.3 상세 설계
##### 메타데이터 데이터베이스
##### 전송 가능성
##### 검색
- 엘라스틱서치
  - 
- 맞춤형 검색 솔루션
##### 규모 확장성<br>
<img src="292 8.12.png" alt="drawing" width="500px"/><br>
- 가용성 향상을 위해 데이터를 여러 데이터센터에 다중화 필요
- 사용자는 자신과 물리적으로 가까운 메일 서버와 통신
- 네트워크 파티션, 즉 통신 불가능 네트워크 영역이 생기면 다른 데이터센터에 보관된 메시지 이용
  